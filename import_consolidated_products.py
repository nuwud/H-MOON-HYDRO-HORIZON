#!/usr/bin/env python3
"""Import consolidated Shopify products via the Admin REST API.

Reads ``variant_consolidation.csv`` (generated by ``consolidate_variants.py``)
with one row per variant and creates/updates products in Shopify.

Features
--------
* Groups variants by handle to build complete product payloads.
* Optionally overwrites existing products that share the same handle.
* Sets variant inventory quantities at the configured Shopify location.
* Supports dry-run mode for verification before making live changes.

Required environment variables
------------------------------
* ``SHOPIFY_ACCESS_TOKEN`` ‚Äì Admin API access token.
* ``SHOPIFY_DOMAIN`` ‚Äì Store domain without protocol (e.g. ``h-moon-hydro`` or
  ``h-moon-hydro.myshopify.com``).
* ``SHOPIFY_LOCATION_ID`` ‚Äì Location ID used for inventory assignment.

Optional
--------
* ``SHOPIFY_API_VERSION`` ‚Äì Defaults to ``2023-10`` to match the rest of the
  tooling in this repo.
"""

from __future__ import annotations

import argparse
import csv
import json
import os
import sys
import time
from collections import OrderedDict
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, Iterable, List, Optional

import requests

SHOPIFY_API_VERSION = os.environ.get("SHOPIFY_API_VERSION", "2023-10")
DEFAULT_CSV_PATH = Path("outputs/variant_consolidation/variant_consolidation.csv")
DEFAULT_THROTTLE = 0.5


@dataclass
class VariantRow:
    raw: Dict[str, str]

    @property
    def sku(self) -> str:
        return (self.raw.get("Variant_SKU") or "").strip()

    @property
    def handle(self) -> str:
        return (self.raw.get("Handle") or "").strip()


def parse_bool(value: str) -> bool:
    return str(value).strip().lower() in {"true", "1", "yes"}


def parse_float(value: str) -> Optional[float]:
    value = (value or "").strip()
    if not value:
        return None
    try:
        return float(value)
    except ValueError:
        return None


def parse_int(value: str) -> Optional[int]:
    value = (value or "").strip()
    if not value:
        return None
    try:
        return int(round(float(value)))
    except ValueError:
        return None


def normalise_domain(domain: str) -> str:
    domain = domain.strip().lower()
    if domain.endswith(".myshopify.com"):
        return domain
    return f"{domain}.myshopify.com"


def load_csv(path: Path) -> OrderedDict[str, List[VariantRow]]:
    if not path.exists():
        raise FileNotFoundError(f"CSV not found: {path}")
    products: "OrderedDict[str, List[VariantRow]]" = OrderedDict()
    with path.open("r", encoding="utf-8", newline="") as handle:
        reader = csv.DictReader(handle)
        for row in reader:
            variant = VariantRow(row)
            handle_key = variant.handle
            products.setdefault(handle_key, []).append(variant)
    return products


def product_exists(session: requests.Session, graphql_url: str, handle: str) -> Optional[str]:
    query = """
    query($handle: String!) {
      productByHandle(handle: $handle) {
        id
      }
    }
    """
    payload = {"query": query, "variables": {"handle": handle}}
    response = session.post(graphql_url, json=payload, timeout=30)
    response.raise_for_status()
    data = response.json()
    product = data.get("data", {}).get("productByHandle")
    if not product:
        return None
    gid = product.get("id")
    if not gid:
        return None
    # gid format: gid://shopify/Product/1234567890
    return gid.split("/")[-1]


def delete_product(session: requests.Session, rest_base: str, product_id: str, throttle: float) -> None:
    url = f"{rest_base}/products/{product_id}.json"
    response = session.delete(url, timeout=30)
    if response.status_code not in (200, 202, 204):
        raise RuntimeError(f"Failed to delete product {product_id}: {response.status_code} {response.text}")
    time.sleep(throttle)


def build_product_payload(handle: str, variants: Iterable[VariantRow]) -> Dict[str, object]:
    variants = list(variants)
    if not variants:
        raise ValueError(f"No variants supplied for handle {handle}")

    first = variants[0].raw
    option_name = first.get("Variant_Option1_Name") or "Title"
    option_name = option_name.strip() or "Title"

    images: List[Dict[str, str]] = []
    seen_images: set[str] = set()

    raw_option_values = [((row.raw.get("Variant_Option1") or "").strip()) for row in variants]
    duplicate_values = {value for value in raw_option_values if value and raw_option_values.count(value) > 1}
    used_option_values: set[str] = set()

    variant_payloads: List[Dict[str, object]] = []

    for variant in variants:
        row = variant.raw
        raw_image_field = (row.get("Image_URL") or "").strip()
        if raw_image_field:
            for image_url in [part.strip() for part in raw_image_field.split("||") if part.strip()] or [raw_image_field]:
                if image_url and image_url not in seen_images:
                    images.append({"src": image_url})
                    seen_images.add(image_url)

        price = (row.get("Variant_Price") or "").strip() or "0.00"
        compare_at = (row.get("Variant_Compare_Price") or "").strip()
        inventory_policy = (row.get("Variant_Inventory_Policy") or "continue").strip().lower()
        if inventory_policy != "continue":
            inventory_policy = "continue"
        inventory_tracker = (row.get("Variant_Inventory_Tracker") or "").strip()
        fulfillment_service = (row.get("Variant_Fulfillment_Service") or "manual").strip() or "manual"
        option_value = (row.get("Variant_Option1") or "").strip() or "Default Title"
        if option_value in duplicate_values:
            fallback_value = (row.get("Variant_Title") or "").strip()
            if fallback_value:
                option_value = fallback_value
            else:
                sku_suffix = (row.get("Variant_SKU") or "").strip()
                option_value = f"{option_value}-{sku_suffix}" if sku_suffix else option_value

        weight = parse_float(row.get("Variant_Weight"))
        weight_unit = (row.get("Variant_Weight_Unit") or "lb").strip().lower()
        if weight_unit not in {"g", "kg", "oz", "lb"}:
            weight_unit = "lb"

        option_value = (row.get("Variant_Option1") or "").strip() or "Default Title"
        if option_value in duplicate_values:
            fallback_value = (row.get("Variant_Title") or "").strip()
            if fallback_value:
                option_value = fallback_value
        if option_value in used_option_values:
            sku_suffix = (row.get("Variant_SKU") or "").strip()
            counter = 1
            candidate = f"{option_value}-{sku_suffix}" if sku_suffix else f"{option_value} ({counter})"
            while candidate in used_option_values:
                counter += 1
                candidate = (
                    f"{option_value}-{sku_suffix}" if sku_suffix else f"{option_value} ({counter})"
                )
            option_value = candidate
        used_option_values.add(option_value)

        variant_payload = {
            "title": row.get("Variant_Title") or option_value,
            "sku": row.get("Variant_SKU") or None,
            "price": price,
            "compare_at_price": compare_at or None,
            "inventory_policy": inventory_policy,
            "inventory_management": inventory_tracker or None,
            "fulfillment_service": fulfillment_service,
            "requires_shipping": parse_bool(row.get("Variant_Requires_Shipping", "True")),
            "taxable": parse_bool(row.get("Variant_Taxable", "True")),
            "barcode": row.get("Variant_Barcode") or None,
            "option1": option_value,
            "weight": weight or 0.0,
            "weight_unit": weight_unit,
        }

        quantity = parse_int(row.get("Variant_Inventory"))
        if quantity is not None:
            variant_payload["inventory_quantity"] = quantity

        variant_payloads.append(variant_payload)

    published_at = (first.get("Published_Date") or "").strip()
    published_iso = None
    if published_at:
        try:
            dt = datetime.strptime(published_at, "%Y-%m-%d %H:%M:%S").replace(tzinfo=timezone.utc)
            published_iso = dt.isoformat()
        except ValueError:
            published_iso = None

    product_payload = {
        "title": first.get("Product_Name") or handle,
        "handle": handle,
        "body_html": first.get("Description") or "",
        "vendor": first.get("Vendor") or "",
        "product_type": first.get("Product_Type") or "",
        "status": (first.get("Status") or "draft").lower(),
        "tags": first.get("Tags") or "",
        "options": [{"name": option_name or "Title"}],
        "variants": variant_payloads,
    }

    if published_iso:
        product_payload["published_at"] = published_iso

    if images:
        product_payload["images"] = images

    return product_payload


def create_product(
    session: requests.Session,
    rest_base: str,
    product_payload: Dict[str, object],
    throttle: float,
) -> Dict[str, object]:
    url = f"{rest_base}/products.json"
    response = session.post(url, json={"product": product_payload}, timeout=60)
    if response.status_code not in (200, 201):
        raise RuntimeError(
            f"Failed to create product {product_payload.get('handle')}: {response.status_code} {response.text}"
        )
    time.sleep(throttle)
    return response.json().get("product", {})


def set_inventory_levels(
    session: requests.Session,
    rest_base: str,
    location_id: str,
    variant_rows: List[VariantRow],
    created_product: Dict[str, object],
    throttle: float,
    dry_run: bool,
) -> None:
    variants = created_product.get("variants", [])
    inventory_lookup = {variant.get("sku"): variant for variant in variants if variant.get("sku")}

    for row in variant_rows:
        sku = row.sku
        qty = parse_int(row.raw.get("Variant_Inventory"))
        if qty is None:
            continue
        variant_payload = inventory_lookup.get(sku)
        if not variant_payload:
            continue
        inventory_item_id = variant_payload.get("inventory_item_id")
        if not inventory_item_id:
            continue
        if dry_run:
            continue
        payload = {
            "inventory_item_id": int(inventory_item_id),
            "location_id": int(location_id),
            "available": int(qty),
        }
        url = f"{rest_base}/inventory_levels/set.json"
        response = session.post(url, json=payload, timeout=30)
        if response.status_code not in (200, 201):
            raise RuntimeError(
                f"Failed to set inventory for SKU {sku}: {response.status_code} {response.text}"
            )
        time.sleep(throttle)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Import consolidated Shopify products via API")
    parser.add_argument("--csv", type=Path, default=DEFAULT_CSV_PATH, help="CSV file path with consolidated variants")
    parser.add_argument("--throttle", type=float, default=DEFAULT_THROTTLE, help="Delay between API calls in seconds")
    parser.add_argument("--offset", type=int, default=0, help="Skip this many products from the start of the CSV")
    parser.add_argument("--limit", type=int, help="Limit number of products imported (for testing)")
    parser.add_argument("--overwrite", action="store_true", help="Delete existing products that share the same handle")
    parser.add_argument("--dry-run", action="store_true", help="Print intended actions without calling the API")
    return parser.parse_args()


def main() -> int:
    args = parse_args()

    access_token = os.environ.get("SHOPIFY_ACCESS_TOKEN")
    domain = os.environ.get("SHOPIFY_DOMAIN")
    location_id = os.environ.get("SHOPIFY_LOCATION_ID")

    missing_env = [
        name
        for name, value in (
            ("SHOPIFY_ACCESS_TOKEN", access_token),
            ("SHOPIFY_DOMAIN", domain),
            ("SHOPIFY_LOCATION_ID", location_id),
        )
        if not value
    ]
    if missing_env:
        print(f"‚ùå Missing required environment variables: {', '.join(missing_env)}", file=sys.stderr)
        return 1

    domain = normalise_domain(domain)
    rest_base = f"https://{domain}/admin/api/{SHOPIFY_API_VERSION}"
    graphql_url = f"https://{domain}/admin/api/{SHOPIFY_API_VERSION}/graphql.json"

    products = load_csv(args.csv)
    total_products = len(products)
    handles = list(products.keys())

    if args.offset:
        if args.offset >= len(handles):
            print(f"‚ùå Offset {args.offset} exceeds total products {len(handles)}", file=sys.stderr)
            return 1
        handles = handles[args.offset :]

    if args.limit is not None:
        handles = handles[: args.limit]

    session = requests.Session()
    session.headers.update(
        {
            "Content-Type": "application/json",
            "Accept": "application/json",
            "X-Shopify-Access-Token": access_token,
        }
    )

    created = 0
    skipped = 0
    for index, handle in enumerate(handles, start=1):
        variant_rows = products[handle]
        print(f"[{index}/{len(handles)}] Processing handle '{handle}' with {len(variant_rows)} variants")
        try:
            product_payload = build_product_payload(handle, variant_rows)
        except Exception as exc:  # pylint: disable=broad-except
            print(f"  ‚ö†Ô∏è  Skipping due to payload error: {exc}")
            skipped += 1
            continue

        existing_id = None
        try:
            existing_id = product_exists(session, graphql_url, handle)
        except requests.HTTPError as exc:
            print(f"  ‚ö†Ô∏è  Failed to check existing product: {exc}")

        if existing_id and not args.overwrite:
            print(f"  ‚è≠Ô∏è  Product already exists (id {existing_id}); skipping (use --overwrite to replace)")
            skipped += 1
            continue

        if existing_id and args.overwrite and not args.dry_run:
            print(f"  üóëÔ∏è  Deleting existing product with id {existing_id}")
            delete_product(session, rest_base, existing_id, args.throttle)

        if args.dry_run:
            print("  üìù Dry run ‚Äì product payload preview:")
            preview = json.dumps(product_payload, indent=2)[:800]
            print("    " + preview.replace("\n", "\n    "))
            created += 1
            continue

        try:
            created_product = create_product(session, rest_base, product_payload, args.throttle)
            set_inventory_levels(session, rest_base, location_id, variant_rows, created_product, args.throttle, args.dry_run)
            created += 1
            print(f"  ‚úÖ Created product id {created_product.get('id')}")
        except Exception as exc:  # pylint: disable=broad-except
            print(f"  ‚ùå Failed to create product: {exc}")
            skipped += 1

    print("\nüéØ Import summary")
    processed_range = f"{args.offset + 1}-{args.offset + len(handles)}" if handles else "0"
    print(f"   ‚Ä¢ Products processed: {len(handles)} of {total_products} (rows {processed_range})")
    print(f"   ‚Ä¢ Products created:  {created}")
    print(f"   ‚Ä¢ Products skipped:   {skipped}")
    if args.dry_run:
        print("   ‚Ä¢ Mode: dry-run (no API writes performed)")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
