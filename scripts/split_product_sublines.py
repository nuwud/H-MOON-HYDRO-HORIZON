#!/usr/bin/env python3
"""
split_product_sublines.py

Reads outputs/audit/grouping_issues.csv, confirms with user which splits to apply,
then applies them live on the WooCommerce server via SSH/WP-CLI.

For each "split", the script will:
 1. Create a new grouped parent product (inheriting category, description, image from original parent)
 2. Move the sub-line children out of the original parent's _children
 3. Link them to the new parent's _children
 4. Set each moved child's exclude-from-catalog and exclude-from-search visibility terms

Usage:
  # Review what would be split (dry-run, default)
  python scripts/split_product_sublines.py

  # Apply a specific split by parent SKU
  python scripts/split_product_sublines.py --parent hmh00648 --confirm

  # Apply all confirmed splits
  python scripts/split_product_sublines.py --all --confirm
"""

from __future__ import annotations

import argparse
import csv
import json
import os
import re
import sys
import tempfile
from datetime import datetime
from pathlib import Path

try:
    import paramiko
    from dotenv import load_dotenv
except ImportError:
    print("Missing deps: pip install paramiko python-dotenv")
    sys.exit(1)

WORKSPACE = Path(__file__).resolve().parent.parent
GROUPING_ISSUES_CSV = WORKSPACE / "outputs" / "audit" / "grouping_issues.csv"
DEC31_EXPORT = WORKSPACE / "CSVs" / "WooExport" / "Products-Export-2025-Dec-31-180709.csv"
OUTPUT_DIR = WORKSPACE / "outputs" / "woo_grouping_waves"

load_dotenv(WORKSPACE / ".env")

SSH_HOST = os.getenv("HMOON_SSH_HOST", "")
SSH_USER = os.getenv("HMOON_SSH_USER", "")
SSH_PASS = os.getenv("HMOON_SSH_PASS", "")
SITE_DIR_RAW = os.getenv("HMOON_SITE_DIR", "~/hmoonhydro.com")


# ────────────────────── FALSE POSITIVE FILTER ──────────────────────
# Grouped parents whose sub-line children are NOT actually a separate product
# line and should NOT be split.
FALSE_POSITIVES = {
    "hmh00661",   # PROfilter — all children ARE the PRO line, parent name includes PRO
    "hmh00584",   # Accessories — single item with "PRO" in brand name
    "hmh00648",   # Can Filter Flanges — Flange Max split already applied (session 2026-02-21)
    "hmh01748",   # Clonex Root Maximizer — ALL children are Soluble (0 regular); parent needs rename not split
}


def load_issues() -> list[dict]:
    if not GROUPING_ISSUES_CSV.exists():
        print(f"ERROR: Run audit_product_integrity.py first to generate {GROUPING_ISSUES_CSV}")
        sys.exit(1)
    with open(GROUPING_ISSUES_CSV, encoding="utf-8") as f:
        issues = list(csv.DictReader(f))
    # Filter out known false positives
    return [i for i in issues if i["parent_sku"] not in FALSE_POSITIVES]


def looks_like_windows_path(path: str) -> bool:
    return bool(re.match(r'^[A-Za-z]:[/\\]', path))


def resolve_site_dir(ssh: paramiko.SSHClient) -> str:
    if looks_like_windows_path(SITE_DIR_RAW):
        site_dir = "~/hmoonhydro.com"
    else:
        site_dir = SITE_DIR_RAW or "~/hmoonhydro.com"
    if "~" in site_dir:
        stdin, stdout, stderr = ssh.exec_command("echo $HOME")
        home = stdout.read().decode().strip()
        site_dir = site_dir.replace("~", home)
    return site_dir


def run_remote(ssh: paramiko.SSHClient, cmd: str) -> tuple[str, str, int]:
    stdin, stdout, stderr = ssh.exec_command(cmd)
    out = stdout.read().decode()
    err = stderr.read().decode()
    code = stdout.channel.recv_exit_status()
    return out, err, code


def build_split_php(issue: dict, new_sku: str, dry_run: bool) -> str:
    """Generate PHP that creates a new grouped parent and moves sub-line children."""
    parent_sku = issue["parent_sku"]
    parent_name = issue["parent_name"]
    subline = issue["subline"]
    new_parent_name = f"{parent_name} {subline}"
    # We match children by keyword in title, not by exact name from CSV
    # The keyword is the subline label itself (e.g., "Max", "Liquid", "Pro", etc.)
    keyword = subline.lower()
    dry_run_php = "false" if not dry_run else "true"
    # For "Liquid" sublines: we want children whose title STARTS WITH "Liquid" or CONTAINS "Liquid"
    # For "Max/Pro/Powder/Soluble": title ENDS WITH or CONTAINS keyword

    return f"""<?php
// split_subline_{parent_sku}.php — generated by split_product_sublines.py
$dry_run = {dry_run_php};
$parent_sku = '{parent_sku}';
$new_sku = '{new_sku}';
$new_parent_name = '{new_parent_name.replace("'", "\\'")}';
$keyword = '{keyword}';

// Find original parent by SKU
$parent_q = new WP_Query([
    'post_type' => 'product',
    'meta_key' => '_sku',
    'meta_value' => $parent_sku,
    'posts_per_page' => 1,
]);
if (!$parent_q->have_posts()) {{
    die("ERROR: Parent SKU $parent_sku not found\\n");
}}
$parent_id = $parent_q->posts[0]->ID;
$parent_post = get_post($parent_id);

// Get current children IDs
$current_children = get_post_meta($parent_id, '_children', true);
if (!is_array($current_children)) {{
    $current_children = !empty($current_children) ? (array) @unserialize($current_children) : [];
}}

// Classify children by keyword match in title
$subline_ids = [];
$remaining_children = [];
foreach ($current_children as $child_id) {{
    $child_post = get_post((int)$child_id);
    if (!$child_post) {{ continue; }}
    $title_lower = strtolower($child_post->post_title);
    // Match: title contains keyword as a whole word
    if (preg_match('/\\b' . preg_quote($keyword, '/') . '\\b/i', $title_lower)) {{
        $subline_ids[] = (int)$child_id;
        echo "  [SUBLINE] $child_id: {{$child_post->post_title}}\\n";
    }} else {{
        $remaining_children[] = (int)$child_id;
        echo "  [KEEP]    $child_id: {{$child_post->post_title}}\\n";
    }}
}}

echo "\\nFound parent: $parent_id ({{$parent_post->post_title}})\\n";
echo "Current children: " . count($current_children) . "\\n";
echo "Sub-line children to move: " . count($subline_ids) . "\\n";
echo "Children staying with original parent: " . count($remaining_children) . "\\n";

if (empty($subline_ids)) {{
    die("ERROR: No sub-line children matched keyword '$keyword' — aborting.\\n");
}}

// Check if new parent already exists by SKU
$existing = new WP_Query([
    'post_type' => 'product',
    'meta_key' => '_sku',
    'meta_value' => $new_sku,
    'posts_per_page' => 1,
]);
$new_parent_id = $existing->have_posts() ? $existing->posts[0]->ID : null;

echo "Mode: " . ($dry_run ? "DRY-RUN" : "CONFIRM") . "\\n";

if (!$dry_run) {{
    // Get original parent's category, image, description
    $cat_terms = wp_get_post_terms($parent_id, 'product_cat', ['fields' => 'ids']);
    $thumbnail_id = get_post_thumbnail_id($parent_id);
    $description = $parent_post->post_content;
    $short_desc = $parent_post->post_excerpt;

    // Create new grouped parent if it doesn't exist
    if (!$new_parent_id) {{
        $new_parent_id = wp_insert_post([
            'post_title'   => $new_parent_name,
            'post_type'    => 'product',
            'post_status'  => 'publish',
            'post_content' => $description,
            'post_excerpt' => $short_desc,
        ]);
        if (is_wp_error($new_parent_id)) {{
            die("ERROR creating new parent: " . $new_parent_id->get_error_message() . "\\n");
        }}
        update_post_meta($new_parent_id, '_sku', $new_sku);
        wp_set_object_terms($new_parent_id, 'grouped', 'product_type');
        if ($cat_terms && !is_wp_error($cat_terms)) {{
            wp_set_post_terms($new_parent_id, $cat_terms, 'product_cat');
        }}
        if ($thumbnail_id) {{
            set_post_thumbnail($new_parent_id, $thumbnail_id);
        }}
        echo "Created new parent: $new_parent_id ($new_parent_name) SKU=$new_sku\\n";
    }} else {{
        echo "New parent already exists: $new_parent_id\\n";
    }}

    // Link sub-line children to new parent
    update_post_meta($new_parent_id, '_children', $subline_ids);

    // Set visibility on sub-line children (ensure they stay hidden from catalog/search)
    $exclude_catalog = get_term_by('slug', 'exclude-from-catalog', 'product_visibility');
    $exclude_search = get_term_by('slug', 'exclude-from-search', 'product_visibility');
    foreach ($subline_ids as $child_id) {{
        if ($exclude_catalog && $exclude_search) {{
            wp_set_object_terms($child_id, [$exclude_catalog->term_id, $exclude_search->term_id], 'product_visibility', true);
        }}
    }}

    // Update original parent's children (remove sub-line children)
    update_post_meta($parent_id, '_children', $remaining_children);

    // Clear caches
    wc_delete_product_transients($parent_id);
    wc_delete_product_transients($new_parent_id);

    echo "Updated original parent ($parent_id) children: " . count($remaining_children) . " remaining\\n";
    echo "Linked sub-line children to new parent ($new_parent_id): " . count($subline_ids) . "\\n";
}} else {{
    // Dry-run only
    if ($new_parent_id) {{
        echo "New parent would be updated (already exists): $new_parent_id\\n";
    }} else {{
        echo "New parent would be CREATED: '$new_parent_name' SKU=$new_sku\\n";
    }}
    echo "Would move " . count($subline_ids) . " children to new parent\\n";
    echo "Would leave " . count($remaining_children) . " children with original parent\\n";
    echo "Sub-line child IDs: " . implode(', ', $subline_ids) . "\\n";
}}

$out = [
    'mode' => $dry_run ? 'dry-run' : 'confirm',
    'parent_sku' => $parent_sku,
    'parent_id' => $parent_id,
    'new_sku' => $new_sku,
    'new_parent_name' => $new_parent_name,
    'new_parent_id' => $new_parent_id,
    'subline_children_moved' => count($subline_ids),
    'original_children_remaining' => count($remaining_children),
];
echo 'SPLIT_JSON ' . wp_json_encode($out) . "\\n";
"""


def generate_new_sku(parent_sku: str, subline: str) -> str:
    """Generate a SKU for the new sub-line parent."""
    suffix = re.sub(r'[^a-z0-9]', '', subline.lower())[:6]
    return f"{parent_sku}-{suffix}"


def connect_ssh() -> paramiko.SSHClient:
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(SSH_HOST, username=SSH_USER, password=SSH_PASS, timeout=30)
    return ssh


def apply_split(issue: dict, confirm: bool, site_dir: str, ssh: paramiko.SSHClient) -> dict:
    parent_sku = issue["parent_sku"]
    new_sku = generate_new_sku(parent_sku, issue["subline"])
    dry_run = not confirm
    
    php = build_split_php(issue, new_sku, dry_run)
    
    # Upload PHP via SFTP
    remote_php = f"{site_dir}/wp-content/split_{parent_sku}.php"
    sftp = ssh.open_sftp()
    with sftp.open(remote_php, 'w') as f:
        f.write(php)
    sftp.close()
    
    cmd = f"cd '{site_dir}' && wp eval-file wp-content/split_{parent_sku}.php --allow-root 2>&1"
    out, err, code = run_remote(ssh, cmd)
    
    # Cleanup
    sftp = ssh.open_sftp()
    try:
        sftp.remove(remote_php)
    except Exception:
        pass
    sftp.close()
    
    # Parse JSON result
    result = {}
    for line in out.splitlines():
        if line.startswith("SPLIT_JSON "):
            try:
                result = json.loads(line[len("SPLIT_JSON "):])
            except Exception:
                pass
    
    print(f"\n[{parent_sku}] {issue['parent_name']} → {issue['subline']}")
    print(out.strip())
    if err.strip():
        print(f"STDERR: {err.strip()[:300]}")
    
    return result


def main():
    parser = argparse.ArgumentParser(description="Split WooCommerce grouped product sub-lines")
    parser.add_argument("--parent", help="Only process this parent SKU")
    parser.add_argument("--all", action="store_true", help="Process all detected issues")
    parser.add_argument("--confirm", action="store_true", help="Actually apply changes (default: dry-run)")
    parser.add_argument("--list", action="store_true", help="Just list detected issues and exit")
    args = parser.parse_args()

    issues = load_issues()
    
    if args.list or (not args.parent and not args.all):
        print(f"\nDetected grouping sub-line issues (excluding known false positives):\n")
        print(f"{'Parent SKU':<15} {'Parent Name':<40} {'Sub-line':<12} {'Children':<10} Suggested Action")
        print("-" * 120)
        for i in issues:
            print(f"{i['parent_sku']:<15} {i['parent_name'][:38]:<40} {i['subline']:<12} {i['subline_children_count']:<10} {i['suggested_action'][:50]}")
        print(f"\nTotal: {len(issues)} issues")
        print(f"\nUsage:")
        print(f"  python scripts/split_product_sublines.py --parent hmh00648        # dry-run one")
        print(f"  python scripts/split_product_sublines.py --parent hmh00648 --confirm  # apply one")
        print(f"  python scripts/split_product_sublines.py --all --confirm          # apply all")
        return
    
    # Filter to requested issues
    if args.parent:
        to_process = [i for i in issues if i["parent_sku"] == args.parent]
        if not to_process:
            print(f"No issue found for parent SKU: {args.parent}")
            print(f"Available: {[i['parent_sku'] for i in issues]}")
            sys.exit(1)
    else:
        to_process = issues
    
    confirm = args.confirm
    mode = "CONFIRM" if confirm else "DRY-RUN"
    print(f"\nMode: {mode}")
    print(f"Processing {len(to_process)} issue(s)...")
    
    ssh = connect_ssh()
    site_dir = resolve_site_dir(ssh)
    print(f"Site dir: {site_dir}")
    
    # Take DB backup before any confirms
    if confirm:
        backup_dir = f"{site_dir}/wp-content/backups"
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = f"{backup_dir}/subline_split_{ts}.sql"
        run_remote(ssh, f"mkdir -p {backup_dir}")
        out, err, code = run_remote(ssh, f"cd '{site_dir}' && wp db export '{backup_path}' --allow-root")
        if code == 0:
            print(f"DB backup: {backup_path}")
        else:
            print(f"WARNING: DB backup failed: {err[:100]}")
    
    results = []
    for issue in to_process:
        result = apply_split(issue, confirm, site_dir, ssh)
        results.append(result)
    
    ssh.close()
    
    print(f"\n{'='*60}")
    print(f"DONE — {len(results)} split(s) processed")
    for r in results:
        if r:
            print(f"  [{r.get('mode','?')}] {r.get('parent_sku','?')} → moved {r.get('subline_children_moved',0)}, "
                  f"remaining {r.get('original_children_remaining',0)}, new parent {r.get('new_parent_id','?')}")


if __name__ == "__main__":
    main()
