#!/usr/bin/env npx tsx
/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * FILE: uploadGapFilesToShopify.ts
 * PURPOSE: Upload specific files from the gap report to Shopify Files
 * 
 * Reads outputs/files_to_upload.json (generated by rewriteFinalImportCsvWithFilesManifest.ts)
 * and uploads each file to Shopify Files, updating files_manifest.json
 * 
 * Usage:
 *   npx tsx src/cli/uploadGapFilesToShopify.ts --dry-run
 *   npx tsx src/cli/uploadGapFilesToShopify.ts --confirm
 *   npx tsx src/cli/uploadGapFilesToShopify.ts --confirm --limit=50
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import { fileURLToPath } from 'url';
import { config } from 'dotenv';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const PROJECT_ROOT = path.resolve(__dirname, '../..');
const BASE_DIR = path.resolve(__dirname, '../../..');
const OUTPUTS_DIR = path.resolve(BASE_DIR, 'outputs');

// Load .env from hmoon-pipeline directory
config({ path: path.resolve(PROJECT_ROOT, '.env') });

const SHOPIFY_DOMAIN = process.env.SHOPIFY_DOMAIN || process.env.SHOPIFY_STORE;
const SHOPIFY_ADMIN_TOKEN = process.env.SHOPIFY_ADMIN_TOKEN || process.env.SHOPIFY_ACCESS_TOKEN;
const API_VERSION = process.env.SHOPIFY_API_VERSION || '2024-10';

// ============================================================================
// Types
// ============================================================================

interface FileToUpload {
  localPath: string;
  filename: string;
  sha1: string;
}

interface ManifestEntry {
  originalFilename: string;
  shopifyFilename: string;
  sha1: string;
  shopifyUrl: string;
  shopifyFileId: string;
  uploadedAt: string;
  originalPath: string;
  sizeBytes: number;
}

interface FilesManifest {
  byFilename: Record<string, ManifestEntry>;
  bySha1: Record<string, ManifestEntry>;
  stats: {
    totalUploaded: number;
    lastUpdated: string;
  };
}

// ============================================================================
// CLI Arguments
// ============================================================================

const args = process.argv.slice(2);
const isDryRun = !args.includes('--confirm');
const limitArg = args.find(a => a.startsWith('--limit='));
const limit = limitArg ? parseInt(limitArg.split('=')[1]) : Infinity;
const gapFileArg = args.find(a => a.startsWith('--gap-file='));
const gapFilePath = gapFileArg ? path.resolve(gapFileArg.split('=')[1]) : null;

// ============================================================================
// Utilities
// ============================================================================

function loadManifest(manifestPath: string): FilesManifest {
  if (fs.existsSync(manifestPath)) {
    return JSON.parse(fs.readFileSync(manifestPath, 'utf-8'));
  }
  return {
    byFilename: {},
    bySha1: {},
    stats: { totalUploaded: 0, lastUpdated: new Date().toISOString() }
  };
}

function saveManifest(manifest: FilesManifest, manifestPath: string): void {
  manifest.stats.lastUpdated = new Date().toISOString();
  manifest.stats.totalUploaded = Object.keys(manifest.byFilename).length;
  fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));
}

async function graphqlRequest(query: string, variables: Record<string, unknown> = {}): Promise<any> {
  const url = `https://${SHOPIFY_DOMAIN}/admin/api/${API_VERSION}/graphql.json`;
  
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Shopify-Access-Token': SHOPIFY_ADMIN_TOKEN!,
    },
    body: JSON.stringify({ query, variables }),
  });

  if (!response.ok) {
    const text = await response.text();
    throw new Error(`GraphQL request failed: ${response.status} - ${text}`);
  }

  return response.json();
}

// ============================================================================
// Shopify Upload Function
// ============================================================================

async function uploadToShopifyFiles(
  filePath: string, 
  originalFilename: string,
  shopifyFilename: string,
  sha1: string
): Promise<{ url: string; fileId: string } | null> {
  const buffer = fs.readFileSync(filePath);
  const ext = path.extname(originalFilename).toLowerCase().slice(1);
  
  const mimeTypes: Record<string, string> = {
    'jpg': 'image/jpeg',
    'jpeg': 'image/jpeg',
    'png': 'image/png',
    'gif': 'image/gif',
    'webp': 'image/webp',
  };
  const mimeType = mimeTypes[ext] || 'image/jpeg';

  // Step 1: Create staged upload
  const stagedQuery = `
    mutation stagedUploadsCreate($input: [StagedUploadInput!]!) {
      stagedUploadsCreate(input: $input) {
        stagedTargets {
          url
          resourceUrl
          parameters {
            name
            value
          }
        }
        userErrors {
          field
          message
        }
      }
    }
  `;

  const stagedResult = await graphqlRequest(stagedQuery, {
    input: [{
      resource: 'FILE',
      filename: shopifyFilename,
      mimeType: mimeType,
      fileSize: buffer.length.toString(),
      httpMethod: 'POST',
    }],
  });

  if (stagedResult.errors) {
    console.error(`   âŒ GraphQL error:`, stagedResult.errors);
    return null;
  }

  if (stagedResult.data?.stagedUploadsCreate?.userErrors?.length > 0) {
    console.error(`   âŒ Staged upload error:`, stagedResult.data.stagedUploadsCreate.userErrors);
    return null;
  }

  const target = stagedResult.data?.stagedUploadsCreate?.stagedTargets?.[0];
  if (!target) {
    console.error(`   âŒ No staged target returned`);
    return null;
  }

  // Step 2: Upload file to staged URL
  const formData = new FormData();
  for (const param of target.parameters) {
    formData.append(param.name, param.value);
  }
  formData.append('file', new Blob([buffer], { type: mimeType }), shopifyFilename);

  const uploadResponse = await fetch(target.url, {
    method: 'POST',
    body: formData,
  });

  if (!uploadResponse.ok) {
    const text = await uploadResponse.text();
    console.error(`   âŒ Upload failed: ${uploadResponse.status} - ${text.substring(0, 100)}`);
    return null;
  }

  // Step 3: Create file record in Shopify
  const fileCreateQuery = `
    mutation fileCreate($files: [FileCreateInput!]!) {
      fileCreate(files: $files) {
        files {
          id
          alt
          createdAt
          ... on MediaImage {
            image {
              url
            }
          }
        }
        userErrors {
          field
          message
        }
      }
    }
  `;

  const fileResult = await graphqlRequest(fileCreateQuery, {
    files: [{
      originalSource: target.resourceUrl,
      contentType: 'IMAGE',
      alt: originalFilename.replace(/\.[^.]+$/, ''),
    }],
  });

  if (fileResult.data?.fileCreate?.userErrors?.length > 0) {
    console.error(`   âŒ File create error:`, fileResult.data.fileCreate.userErrors);
    return null;
  }

  const file = fileResult.data?.fileCreate?.files?.[0];
  if (!file) {
    console.error(`   âŒ No file returned from fileCreate`);
    return null;
  }

  // Step 4: Poll for file to be ready (Shopify processes asynchronously)
  const fileId = file.id;
  let cdnUrl: string | null = null;
  
  const pollQuery = `
    query fileStatus($ids: [ID!]!) {
      nodes(ids: $ids) {
        ... on MediaImage {
          id
          fileStatus
          image {
            url
          }
        }
        ... on GenericFile {
          id
          fileStatus
          url
        }
      }
    }
  `;

  // Poll up to 10 times with 1-second delay
  for (let attempt = 0; attempt < 10; attempt++) {
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const statusResult = await graphqlRequest(pollQuery, { ids: [fileId] });
    const node = statusResult.data?.nodes?.[0];
    
    if (node?.fileStatus === 'READY') {
      cdnUrl = node.image?.url || node.url;
      break;
    } else if (node?.fileStatus === 'FAILED') {
      console.error(`   âŒ File processing failed`);
      return null;
    }
  }

  if (!cdnUrl) {
    console.error(`   âš ï¸ File still processing after timeout, using resourceUrl`);
    cdnUrl = target.resourceUrl;
  }

  return { url: cdnUrl as string, fileId };
}

// ============================================================================
// Main
// ============================================================================

async function main() {
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('        UPLOAD GAP FILES TO SHOPIFY FILES');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

  // Validate environment
  if (!SHOPIFY_DOMAIN || !SHOPIFY_ADMIN_TOKEN) {
    console.error('âŒ Missing Shopify credentials in .env');
    console.error('   Required: SHOPIFY_DOMAIN and SHOPIFY_ADMIN_TOKEN');
    process.exit(1);
  }

  console.log(`ğŸª Store: ${SHOPIFY_DOMAIN}`);
  console.log(`ğŸ”§ Mode: ${isDryRun ? 'DRY RUN (preview only)' : 'âš ï¸  LIVE - Will upload files'}`);
  if (limit < Infinity) {
    console.log(`ğŸ“¦ Limit: ${limit} files`);
  }
  console.log();

  // Load files to upload
  const filesToUploadPath = gapFilePath || path.join(OUTPUTS_DIR, 'files_to_upload.json');
  if (!fs.existsSync(filesToUploadPath)) {
    console.error(`âŒ ${path.basename(filesToUploadPath)} not found at ${filesToUploadPath}`);
    console.error('   Run rewriteFinalImportCsvWithFilesManifest.ts first to generate it');
    process.exit(1);
  }

  // Load and normalize the file list (support both formats)
  const rawFiles = JSON.parse(fs.readFileSync(filesToUploadPath, 'utf-8'));
  const filesToUpload: FileToUpload[] = rawFiles.map((f: any) => {
    // Handle different file formats
    const localPath = f.localPath ? path.resolve(BASE_DIR, f.localPath) : null;
    const filename = f.filename || (localPath ? path.basename(localPath) : '');
    
    // Compute SHA1 if not provided and file exists
    let sha1 = f.sha1 || '';
    if (!sha1 && localPath && fs.existsSync(localPath)) {
      const buffer = fs.readFileSync(localPath);
      sha1 = crypto.createHash('sha1').update(buffer).digest('hex');
    }
    
    return { localPath, filename, sha1 };
  }).filter((f: FileToUpload) => f.localPath && fs.existsSync(f.localPath));
  
  console.log(`ğŸ“· Files to upload: ${filesToUpload.length}`);

  // Load existing manifest
  const manifestPath = path.join(OUTPUTS_DIR, 'files_manifest.json');
  const manifest = loadManifest(manifestPath);
  console.log(`ğŸ“‹ Existing manifest: ${Object.keys(manifest.byFilename).length} files\n`);

  // Filter out already uploaded files
  const needsUpload = filesToUpload.filter(f => !manifest.bySha1[f.sha1]);
  console.log(`ğŸ”„ Already in manifest: ${filesToUpload.length - needsUpload.length}`);
  console.log(`ğŸ“¤ Need to upload: ${needsUpload.length}\n`);

  if (needsUpload.length === 0) {
    console.log('âœ… All files already in manifest!');
    return;
  }

  if (isDryRun) {
    console.log('ğŸ”¸ DRY RUN - No files will be uploaded');
    console.log('   Run with --confirm to upload\n');
    console.log('Sample files that would be uploaded:');
    needsUpload.slice(0, 10).forEach(f => console.log(`   ${f.filename}`));
    if (needsUpload.length > 10) {
      console.log(`   ... and ${needsUpload.length - 10} more`);
    }
    return;
  }

  // Process uploads
  const processQueue = needsUpload.slice(0, limit);
  console.log(`ğŸ”„ Uploading ${processQueue.length} files...\n`);

  let uploaded = 0;
  let failed = 0;

  for (let i = 0; i < processQueue.length; i++) {
    const file = processQueue[i];
    const progress = `[${i + 1}/${processQueue.length}]`;
    
    // Verify file exists
    if (!fs.existsSync(file.localPath)) {
      console.log(`${progress} âš ï¸ File not found: ${file.filename}`);
      failed++;
      continue;
    }

    // Create collision-proof Shopify filename: <sha1_8>__<original>
    const shopifyFilename = `${file.sha1.slice(0, 8)}__${file.filename}`;
    const sizeBytes = fs.statSync(file.localPath).size;
    
    console.log(`${progress} ${file.filename}`);

    try {
      const result = await uploadToShopifyFiles(file.localPath, file.filename, shopifyFilename, file.sha1);
      
      if (result) {
        console.log(`   âœ… ${result.url.substring(0, 60)}...`);
        
        // Extract relative path from local path
        const uploadsMatch = file.localPath.match(/uploads[/\\](.+)/);
        const originalPath = uploadsMatch ? uploadsMatch[1].replace(/\\/g, '/') : file.filename;

        const entry: ManifestEntry = {
          originalFilename: file.filename,
          shopifyFilename,
          sha1: file.sha1,
          shopifyUrl: result.url,
          shopifyFileId: result.fileId,
          uploadedAt: new Date().toISOString(),
          originalPath,
          sizeBytes,
        };

        manifest.bySha1[file.sha1] = entry;
        manifest.byFilename[file.filename] = entry;
        uploaded++;

        // Save manifest periodically
        if (uploaded % 10 === 0) {
          saveManifest(manifest, manifestPath);
        }
      } else {
        failed++;
      }
    } catch (error) {
      console.error(`   âŒ Error: ${error}`);
      failed++;
    }

    // Rate limiting
    await new Promise(resolve => setTimeout(resolve, 500));
  }

  // Final save
  saveManifest(manifest, manifestPath);

  // Summary
  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('                        UPLOAD SUMMARY');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log(`Processed: ${processQueue.length}`);
  console.log(`Uploaded: ${uploaded}`);
  console.log(`Failed: ${failed}`);
  console.log(`\nManifest: ${Object.keys(manifest.byFilename).length} total files`);
  console.log(`Saved to: outputs/files_manifest.json`);
  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
}

main().catch(console.error);
