#!/usr/bin/env python3
"""Update Shopify export data using the official POS inventory sheet.

This script consumes three inputs:

1. The latest Shopify product export (`products_export_1.csv` by default).
2. The master POS sheet provided by the client (`HMoonHydro_Inventory.csv`).
3. The alignment workbook generated by ``align_pos_inventory.py`` which records
   which POS item corresponds to each Shopify variant (`pos_shopify_alignment.csv`).

For every variant where the alignment file specifies a POS item number, the
script copies inventory quantities, pricing, cost, barcode, and vendor data from
the POS sheet into a fresh Shopify import CSV. Results are written to
``CSVs/shopify_inventory_from_pos.csv`` by default along with a JSON summary of
the updates applied. The original export is never modified in-place.
"""

from __future__ import annotations

import argparse
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, Tuple

import pandas as pd


POS_QTY_PREFIX = "Qty "


@dataclass
class PosSnapshot:
    """Subset of POS fields we rely on for synchronisation."""

    item_number: str
    regular_price: float
    msrp: float
    average_cost: float
    order_cost: float
    tax_code: str
    barcode: str
    vendor: str
    description: str
    qty_total: float


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Sync Shopify export values from POS inventory")
    parser.add_argument(
        "--shopify",
        type=Path,
        default=Path("products_export_1.csv"),
        help="Path to the Shopify export CSV used as the update base",
    )
    parser.add_argument(
        "--pos",
        type=Path,
        default=Path("CSVs/HMoonHydro_Inventory.csv"),
        help="Path to the official POS inventory CSV",
    )
    parser.add_argument(
        "--alignment",
        type=Path,
        default=Path("outputs/inventory/pos_shopify_alignment.csv"),
        help="Alignment CSV that maps Shopify SKUs to POS item numbers",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("CSVs/shopify_inventory_from_pos.csv"),
        help="Destination CSV for the updated Shopify data",
    )
    parser.add_argument(
        "--summary",
        type=Path,
        default=Path("CSVs/shopify_inventory_from_pos_summary.json"),
        help="Path for the JSON summary report",
    )
    return parser.parse_args()


def normalise_item_number(raw: str) -> str:
    raw = (raw or "").strip()
    if raw.endswith(".0"):
        raw = raw[:-2]
    return raw


def to_float(value: str) -> float:
    try:
        return float(value)
    except (TypeError, ValueError):
        return 0.0


def to_int(value: float) -> int:
    try:
        return int(round(float(value)))
    except (TypeError, ValueError):
        return 0


def load_pos_snapshots(path: Path) -> Dict[str, PosSnapshot]:
    if not path.exists():
        raise FileNotFoundError(f"POS inventory CSV not found: {path}")

    df = pd.read_csv(path, dtype=str).fillna("")
    qty_columns = [col for col in df.columns if col.startswith(POS_QTY_PREFIX)]
    qty_totals = df[qty_columns].apply(pd.to_numeric, errors="coerce").fillna(0.0).sum(axis=1)

    snapshots: Dict[str, PosSnapshot] = {}
    for idx, row in df.iterrows():
        item_number = normalise_item_number(row.get("Item Number", ""))
        if not item_number:
            continue
        snapshots[item_number] = PosSnapshot(
            item_number=item_number,
            regular_price=to_float(row.get("Regular Price", "")),
            msrp=to_float(row.get("MSRP", "")),
            average_cost=to_float(row.get("Average Unit Cost", "")),
            order_cost=to_float(row.get("Order Cost", "")),
            tax_code=(row.get("Tax Code", "") or "").strip(),
            barcode=(row.get("UPC", "") or "").strip(),
            vendor=(row.get("Vendor Name", "") or "").strip(),
            description=(row.get("Item Description", "") or "").strip(),
            qty_total=float(qty_totals.iloc[idx]),
        )
    return snapshots


def load_alignment(path: Path) -> Dict[str, str]:
    if not path.exists():
        raise FileNotFoundError(f"Alignment CSV not found: {path}")

    df = pd.read_csv(path, dtype=str).fillna("")
    mapping: Dict[str, str] = {}
    for _, row in df.iterrows():
        sku = (row.get("Variant SKU", "") or "").strip()
        item_number = normalise_item_number(row.get("POS Item Number", ""))
        if sku and item_number:
            mapping[sku] = item_number
    return mapping


def should_mark_taxable(tax_code: str) -> str:
    code = (tax_code or "").strip().lower()
    if not code:
        return "TRUE"
    exempt_tokens = {"non", "nontax", "exempt", "zero", "no tax"}
    return "FALSE" if any(token in code for token in exempt_tokens) else "TRUE"


def choose_cost(snapshot: PosSnapshot) -> float:
    if snapshot.order_cost > 0:
        return snapshot.order_cost
    if snapshot.average_cost > 0:
        return snapshot.average_cost
    return 0.0


def update_shopify_rows(
    shopify_df: pd.DataFrame,
    alignment: Dict[str, str],
    pos_snapshots: Dict[str, PosSnapshot],
) -> Tuple[pd.DataFrame, Dict[str, int]]:
    updates_applied = {
        "inventory": 0,
        "price": 0,
        "compare_at": 0,
        "cost": 0,
        "barcode": 0,
        "vendor": 0,
        "taxable": 0,
    }

    updated_rows = []
    for _, row in shopify_df.iterrows():
        sku = (row.get("Variant SKU", "") or "").strip()
        if not sku:
            updated_rows.append(row)
            continue

        item_number = alignment.get(sku)
        if not item_number:
            updated_rows.append(row)
            continue

        snapshot = pos_snapshots.get(item_number)
        if snapshot is None:
            updated_rows.append(row)
            continue

        new_row = row.copy()

        qty = to_int(snapshot.qty_total)
        new_row["Variant Inventory Qty"] = str(max(qty, 0))
        if qty >= 0:
            updates_applied["inventory"] += 1

        # Ensure Shopify tracks inventory internally
        if not (new_row.get("Variant Inventory Tracker", "") or "").strip():
            new_row["Variant Inventory Tracker"] = "shopify"

        if (new_row.get("Variant Inventory Policy", "") or "").strip() == "":
            new_row["Variant Inventory Policy"] = "deny"

        price = snapshot.regular_price
        if price > 0:
            formatted_price = f"{price:.2f}"
            if (new_row.get("Variant Price", "") or "").strip() != formatted_price:
                updates_applied["price"] += 1
            new_row["Variant Price"] = formatted_price

        compare_at_price = snapshot.msrp
        if compare_at_price > price and compare_at_price > 0:
            formatted_compare = f"{compare_at_price:.2f}"
            if (new_row.get("Variant Compare At Price", "") or "").strip() != formatted_compare:
                updates_applied["compare_at"] += 1
            new_row["Variant Compare At Price"] = formatted_compare
        else:
            if (new_row.get("Variant Compare At Price", "") or "").strip():
                updates_applied["compare_at"] += 1
            new_row["Variant Compare At Price"] = ""

        cost = choose_cost(snapshot)
        if cost > 0:
            formatted_cost = f"{cost:.2f}"
            if (new_row.get("Cost per item", "") or "").strip() != formatted_cost:
                updates_applied["cost"] += 1
            new_row["Cost per item"] = formatted_cost

        if snapshot.barcode and not (new_row.get("Variant Barcode", "") or "").strip():
            new_row["Variant Barcode"] = snapshot.barcode
            updates_applied["barcode"] += 1

        if snapshot.vendor and not (new_row.get("Vendor", "") or "").strip():
            new_row["Vendor"] = snapshot.vendor
            updates_applied["vendor"] += 1

        taxable_flag = should_mark_taxable(snapshot.tax_code)
        if (new_row.get("Variant Taxable", "") or "").strip().upper() != taxable_flag:
            new_row["Variant Taxable"] = taxable_flag
            updates_applied["taxable"] += 1

        # Optionally copy POS description if Shopify body is empty
        if snapshot.description and not (new_row.get("Body (HTML)", "") or "").strip():
            new_row["Body (HTML)"] = snapshot.description

        updated_rows.append(new_row)

    updated_df = pd.DataFrame(updated_rows, columns=shopify_df.columns)
    return updated_df, updates_applied


def write_csv(path: Path, df: pd.DataFrame) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    df.to_csv(path, index=False)


def write_summary(path: Path, summary: Dict[str, object]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(json.dumps(summary, indent=2))


def main() -> None:
    args = parse_args()

    if not args.shopify.exists():
        raise FileNotFoundError(f"Shopify export CSV not found: {args.shopify}")

    shopify_df = pd.read_csv(args.shopify, dtype=str).fillna("")
    alignment = load_alignment(args.alignment)
    pos_snapshots = load_pos_snapshots(args.pos)

    updated_df, counters = update_shopify_rows(shopify_df, alignment, pos_snapshots)
    write_csv(args.output, updated_df)

    summary = {
        "shopify_rows": int(len(shopify_df)),
        "aligned_variants": int(len(alignment)),
        "pos_items_available": int(len(pos_snapshots)),
        "updates": counters,
        "output_csv": str(args.output),
    }
    write_summary(args.summary, summary)

    print("Shopify inventory synchronisation complete")
    print("=" * 44)
    for key, value in counters.items():
        print(f"{key.title():<12}: {value}")
    print()
    print(f"Updated CSV : {args.output}")
    print(f"Summary JSON: {args.summary}")


if __name__ == "__main__":
    main()
